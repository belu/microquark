# microquark

A little project to explore the integration of [MicroStream](http://microstream.one),
[Quarkus](http://quarkus.io) and optionally [GraalVM](http://www.graalvm.org).

## Build & run

See [README.orig.md](README.orig.md) for the original README generated by Quarkus. There you find
all the commands on how to build and run the application.

## Storage types

Support for the following storage types have been implemented for this project.

### Mem

Stores data in-memory. This means after restarting the application
the store is empty again.

### Filesystem

Stores data to your local file system.

### JDBC

#### PostgreSQL

#### MariaDB

### MongoDB

Use docker-compose to start a PostgreSQL instance.

```shell script
docker-compose up
```

## REST API

FIXME New data model.

Get current message:

```shell script
curl http://0.0.0.0:8080/hello
```

Post new message:

```shell script
curl -X POST -H "Content-Type: text/plain" -d "Hello @ $(date)" http://0.0.0.0:8080/hello
```


## How to update the native build configs

If you change code in the application, you probably have to update the configs for
the native build.

For this to work you need GraalVM installed locally on your machine. For instructions have
a look at the GraalVM documentation:
https://www.graalvm.org/docs/getting-started/#install-graalvm

1. Build the application JAR:

```shell script
mvn clean compile package
```

2. Run the application JAR and let Graal do the heavy work to create the native build configs: 

```shell script
java -agentlib:native-image-agent=config-merge-dir=src/main/resources/META-INF/native-image -jar target/*-runner.jar
```

Note that whilst your application is running, you should enter every possible code path that
could occure. This assures that Graal catches all configs that are required.
Ideally, this is done with automated tests.
